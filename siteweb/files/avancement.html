<html><head>
        <title>RG2A Avancement</title>

        <meta charset="utf-8">
        <meta http-equiv="Content-type" content="text/html; charset=utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style type="text/css">
body {
    background-color: #f0f0f2;
    margin: 0;
    padding: 0;
    font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;

}
    div {
        width: 600px;
        margin: 5em auto;
        padding: 2em;
        background-color: #fdfdff;
        border-radius: 0.5em;
        box-shadow: 2px 3px 7px 2px rgba(0,0,0,0.02);
    }
    a:link, a:visited {
        color: #38488f;
        text-decoration: none;
    }
    @media (max-width: 700px) {
        div {
            margin: 0 auto;
            width: auto;
        }
    }
        </style>
    </head>

    <body>
        <div>
            <h1>Avancement</h1>
            <a>
                <h2>Début du projet</h2>
                <p>30/01/2023</p>
                <p>RG2A </p>

                <h2>Soutenance 1</h2>
                <p>15/02/2023</p>
                <p>Lors de la première soutenance, nous avons implémenté
                l'algorithme de Boids, le pathfinding, un paint et une 
                interface graphique.</p>

                <h3>L'implémentation de l'algorithme de Boids</h3>
                <p>Comment les boids sont-ils représentés dans notre 
                implémentation ?</p>
                <p>Il n’existe pas de meilleure approche pour représenter un 
                boid, mais dans notre cas, nous avons utilisé des triangles 
                isocèles. Cela a été fait non seulement pour des raisons 
                esthétiques mais aussi pour rendre l’algorithme plus simple 
                à mettre en œuvre et à comprendre.</p>

                <p>Pourquoi un triangle ?</p>
                <p>Nous pouvons mettre en œuvre le comportement souhaité 
                en déterminant si un autre point se trouve sur le côté 
                gauche ou droit de notre boid en utilisant les deux points 
                qui constituent la base du triangle. L’autre point de notre 
                triangle définira la largeur du champ de vision du boid, 
                et plus le champ de vision est large, plus la hauteur de 
                notre boid doit être grande.</p>

                <p>Quels sont les principaux comportements des boids ?</p>
                <p>Il y a trois règles :<br>
                L’alignement : pour rester regroupés les boids essaient de 
                se suivre sur le même chemin.<br>
                La séparation : les boids évitent autant que possible de se 
                coller l’un à l’autre.<br>
                La cohésion : les boids ont tendance à se regrouper entre 
                eux.</p>
                <center><img src="../Images/simu_boid.png" alt="simu_boid" 
                                                           width="85%" height="35%"></center>
                <br><br>
                <h3>Implémentation Path finding</h3>
                <p>Pour l’implementation de l’algorithme de pathfinding 
                nous avons d’abord choisis d’implementer celui de A* qui 
                correspond au mieux a nos demande pour un algorithme de 
                pathfinding le plus general possible. En effet celui-ci 
                recherche le chemins le plus cours entre un point A et un 
                point B en considerant des obstacles. Pour ce faire a 
                cette premiere soutenance l’implementation de cette 
                algortihme et faite sur vecteur de int avec comme valeur 
                possible 0 pour un emplacement libre et 1 pour un 
                emplacement ocuppee. L’algorithme ce base sur une structure 
                fifo avec ordre de prioritee basée sur une valeur 
                heuristic. La valeur heuristice se calcule pour chaque 
                noeud u par heuristic = cout + distance(u,destination), le 
                cout correspond au deplacement total depuis le point de 
                depart.</p>
                <p>Ici le point de départ (0) et le point d'arrivé (#) ainsi
                les obstacles (-), les positions possible( | ) et le chemin 
                trouvé (X).</p>
                <center><img src="../Images/map1.png" alt="map1"·
                                                      width="45%" height="30%">
                    <img src="../Images/map2.png" alt="map2"·
                                                  width="45%" height="30%"></center>
                <p>Ici l'algorithme renvoie tous les chemins dont il est 
                passé, donc y compris le chemin le plus court.</p>
                <h3>Représentation graphique</h3>
                <p>Paint est la première version de l’implémentation des 
                obstacles. Notre Paint fonctionne sur le même principe que 
                le vrai Paint, dessiner sur un plan. A la différence que 
                notre version dessine des rectangles noir en guise 
                d’obstacles sauf sur la cible rouge positionnée de façon
                aléatoire lorsque l’on presse une touche du clavier.<br>
                Le Paint s’activera lorsque le checkbutton obstacle(de 
                l’interface graphique) est activé. Lorsque le click gauche 
                est pressé, et que le curseur de la souris n’est pas en 
                collision avec la cible rouge, un rectangle noir de 
                dimension 10x10 est dessiner sur l’arène (en guise 
                d’obstacle). Le click droit à la même fonctionnalité que le 
                click gauche mais celui-ci efface seulement les obstacles.</p>
                <center><img src="../Images/paintv1.png" alt="paintv1"
                                                         width="70%" height="30%"></center>
                <h3>Interface graphique</h3>
                <p>L’interface graphique est composé de 3 parties :<br>
                - Les paramètres généraux (main set up)<br>
                - Les paramètres de l’équipe 1 (team 1)<br>
                - Les paramètres de l’équipe 2 (team 2)<br>
                <br>
                <center><img src="../Images/interfacev1.png" alt="interfacev1"·
                                                             width="60%" height="50%"></center>
                </p>
        </div>
        <div>
            <h2>Soutenance 2</h2>
            <p>03/04/2023</p>
            <p>Lors de la deuxième soutenance, nous avons implémenté
            la représentation des obstacles, amélioré le pathfinding et lié
            l'interface graphique et la simulation boid.</p>

            <h3>Implémentation de la représentation des obstacles</h3>
            <p>Maintenant lorsque l'utilisateur représente des obstacles
            dans l'arène les boids l'évitent. Les boids étaient seulement
            soumis à l'algorithme de boid, mais maintenant qu'il y a des
            obstacles les boids doivent réagir autrement. Lorsqu'un boid est
            proche d'un obstacle il ne prend plus en compte l'algorithme de
            boid et ses voisins, pour éviter l'obstacle en priorité.<br>
            Lorsque le boid est proche d'un obstacle, il va plus ou moins
            faire une rotation, vers la droite ou la gauche, pour esquiver
            l'obstacle.</p>

            <h3>Implémentation du pathfinding</h3>
            <p>Pour l'implementation de l'algorithme de pathfinding nous
            avons d'abord choisis d'implementer celui de A* qui correspond
            au mieux a nos demande pour un algorithme de pathfinding le plus
            general possible.<br>
            En effet celui-ci recherche le chemins le plus cours entre un
            point A et un point B en considerant des obstacles.<br>
            Pour ce faire a cette premiere soutenance  l'implementation de
            cette algortihme et faite sur vecteur de int avec comme valeur
            possible 0 pour un emplacement libre et 1 pour un emplacement
            occupée.<br>
            L'algorithme ce base sur une structure fifo avec ordre de
            prioritée basée sur une valeur heuristic. La valeur heuristice
            se calcule pour chaque noeud u par heuristic = cout +
            distance(u, destination), le cout correspond au deplacement
            total depuis le point de depart.</p>
            <p>Lors de la soutenance 1 le problème était que l'on ne retrouvait
            pas le chemin retour, exemple sur une carte complexe.
            <center><img src="../Images/map2.png" alt="map2"></center></p>
            <p>Maintenant lors de cette deuxieme soutenance j'ai resolue le
            probleme lorsque il y'a plusieur obstacle sur le trajet. Pour ce
            faire j'ai pensée a plusieurs solutions :<br>
            - Premiere idée a etait d'implementer une liste de pere et de
            distance comme djikstra sur le chemins qu'il renvoyé, cela
            marche mais et tres couteux lors du lancement de l'algorithme et
            donc sur une petit matrice le temps de calcul ce faisait deja
            ressentir.<br>
            - Deuxième idée, apres avoir implementé la remonté du pere sur
            tous les chemins parcourus.<br>
            <p>Voici donc une map sur l'aquelle il ne trouvais pas le chemin
            le plus rapide :
            <center><img src="../Images/mapsolution2.png" alt="mapS2"></center></p>

            <h3>Implémentation de la console de pilotage de la
                simulation</h3>
            <p>Lors de la soutenance 1, nous avons réalisé une interface
            graphique, implémenté l'algorithme de Boid, du pathfinding et
            du paint. Pour cette deuxième soutenance nous avons lié
            l'algorithme de Boid et le paint à l'interface graphique.</p>
            <p>L'interface graphique / console de pilotage : permet de
            paramétrer la simulation.
            <ol>
                <li>Le bouton Start/Pause : permet de lancer la simulation
                    ou de la mettre en pause.</li>
                <li>Le bouton Stop : permet d'arrêter la simulation.</li>
                <li>Le checkbutton Obstacle : permet à l'utilisateur de
                    dessiner des obstacles dans l'arène</li>
                <li>Le cohésion/séparation/alignement slider : permettent de
                    modifier les différents coefficients de Boids.</li>
                <li>e checkbutton algo1/algo2 : n'active pas un algorithme
                    en particulier, il établit des coefficients à
                    l'algorihme de Boids.</li>
            </ol></p>
            <center><img src="../Images/interfacev1.png" alt="interfacev1"
                                                         width="60%" height="50%"></center></p>
            <center>
                <img src="../Images/simulation-v2-1.png" alt="simv2-1"
                                                         width="60%" height="25%">
                <img src="../Images/simulation-v2-2.png" alt="simv2-2"
                                                         width="60%" height="25%">
            </center>
        </div>
        <div>
            <h2>Soutenance finale</h2>
            <p>23/05/2023</p>
            <p>Lors de cette soutenance finale, nous avons implémenté
            le détournement des obstacles,
            l'algorithme des colonies de fourmis, amélioré le pathfinding
            et lié l'algorithme des colonies de fourmis et la pathfinding à
            l'interface graphique.</p>

            <h3>Implémentation de l'algorithme de colonie de fourmis</h3>
            <p>L’algorithme des fourmis est un algorithme inspiré du comportement
            des fourmis, ou d’autres espèces formant un superorganisme, et qui
            constituent une famille de métaheuristique d’optimisation.
            L’idée originale provient de l’observation de l’exploitation des
            ressources alimentaires chez les fourmis. En effet, celles-ci, bien
            qu’ayant individuellement des capacités coginitives limitées, sont
            capables collectivement de trouver le chemin le plus court entre une
            source de nourriture (la cible dans notre cas) et leur nid (dans notre
            cas il n’y en a pas).</p>
            <p>Dans notre cas, les fourmis nous pas de nid et donc ne permettent pas
            de trouver le plus court chemin entre le nid et la cible (la nourriture).
            Ce que nous avons fait pour implémenter cet algorithme c’est :
            Les fourmis se comportent pendant tout le long de la simulation
            comme des boids, en suivant l’algorithme de Boid en fonction des ces
            coefficients.</p>
            <p>Lorsque une fourmis (ou boid) trouve la cible, elle va laisser derriere
            elle des phéromones pour indiquer aux autres fourmis le chemin a la
            cible. Et donc losque une fourmis passe sur l’une de ces phéromones,
            la fourmis se dirige vers la cible. Et lorsqu’elle trouve la cible, elle
            laissera derriere elle des phéromones pour indiquer aux autres fourmis
            etc, jusqu’a que toutes les fourmis est trouvé la cible.
            Dans la simulation les fourmis qui cherche toujours la cible sont
            représentés en bleu foncé, lorsqu’elles ont trouvé la cible en orange et
            lorsqu’elle suive les phéromones en bleu fluot/clair.</p>
            </a>

            <h3>Implémentation de l'algorithme de Path Finding</h3>
            <p>Pour l’implementation de l’algorithme de pathfinding nous avons
            d’abord choisis d’implementer celui de A* qui correspond au mieux
            a nos demande pour un algorithme de pathfinding le plus general
            possible. En effet celui-ci recherche le chemins le plus cours entre un
            point A et un point B en considerant des obstacles. L’algorithme
            ce base sur une structure fifo avec ordre de prioritee basée sur une
            valeur heuristic. La valeur heuristice se calcule pour chaque noeud u
            par heuristic = cout + distance(u, destination), le cout correspond au
            deplacement total depuis le point de depart.</p>
            <p>Lors de cette soutenance nous avons integrer cette algortihme a
            l’ensemble du projet, cependant l’algortihme etait extremement gour-
            mant en ressource de calcul. Il a fallut donc optimiser l’algorithme tout
            en l’adaptant au mieux au projet.</p>
            <p>Nous avions aussi pour projet d’implementer un algorithme qui prend
            seulement un points de départ et qui cherche une cible sur la map
            donnée en entrer. Cette algorithme étants glouton et ralentissez
            l’execution du programme en entier, nous ne l’avons donc pas retenue
            pour ce projet.</p>
            <p>Le path finding sert a chaque boid de trouver leur chemin sur la
            carte en évitant les obstacles. Pour cela nous avions précédemment
            implementer deux algortihme de recherche de plus cours chemin.
            En effet on avait implementer l’algorithme A* qui renvoie le chemin le
            plus cours entre deux points donné.</p>
            <p>Puis une variante qui d’un point donné recherche une cible d’on les
            coordonnées ne sont pas connu et renvoie un chemin parmis ceux les
            plus cours.</p>

            <h3>Détournement des obstacles</h3>
            <p>Le but de cette partie est de permettre aux boids de ne pas transpercer
            les obstacles dans l’arene. Pour se faire chaque boid va devoir analyser
            son environnement et va retenir l’obstacle le proche de lui dans un
            rayon prédéfinie.</p>
            <p>S’il n’y a pas d’obstacle dans son rayon d’observation le boid
            applique l’algorithme de Boid et se comporte normalement.</p>
            <p>Sinon il ne va pas appliquer l’algorithme de Boid sauf pour un
            certain cas et va se focaliser sur comment éviter cet obstacle.
            Les boids sont représentés par des triangles avec 4 positions différentes:</p>
            <p>- Position 0 : représente le sommet a l’avant du boid<br>
            - Position 1 : représente le sommet droit du triangle<br>
            - Position 2 : représente le sommet gauche du triangle<br>
            - Position 3 : représente le centre du triangle</p>
            <center>
                <img src="../Images/boid_triangle_pos.png" alt="triangle_pos">
            </center>
            <p>Avec ces 4 positions et les distances entre l’obstacle et ces 4 positions,
            on peux savoir de quel coté le boid doit se diriger et a quelle intensité.</p>
            <p>Si la distance obstacle/position0 est la plus grande des distances, on
            sait que l’obstacle n’est pas sur le chemin du boid et donc on considere
            qu’il n’y a pas d’obstacle.</p>
            <p>Sinon, si la distance obstacle/position1 est plus petite que celle de
            l’obstacle/position2, on sait que l’obstacle est a droite et donc que le
            boid doit s’orienter vers la gauche.</p>
            <p>Si la distance obstacle/position2 est plus petite que la distance
            obstacle/position1, on sait que l’obstacle est a gauche et donc que le
            boid doit s’orienter vers la droite.</p>
            <p>De plus, plus la distance entre l’obstacle et le centre du boid
            (position3) est petite, plus l’angle de détournement sera important</p>

            <h3>Interface graphique: réunification des deux algorithmes
                de recherche</h3>
            <p>Lors de la soutenance 1, nous avons réalisé une interface graphique,
            implémenté l’algorithme de Boid, le pathfinding et un paint. Lors
            de la soutenance 2, nous avons lié l’algorithme de Boid et le paint a
            l’interface graphique. Et pour cette derniere soutenance, nous avons lié
            les deux algorithmes de recherche (l’algorithme de colonies de fourmis
            et le path finding) a l’interface graphique et a la simulation.
            L’interface graphique / console de pilotage : permet de paramétrer la
            simulation.</p>
            <p>    Le bouton Start/Pause : permet de lancer la simulation ou de
            la mettre en pause.
            <br>
            Le bouton Stop : permet d’arrêter la simulation.
            <br>
            Le checkbutton Obstacle : permet à l’utilisateur de dessiner des
            obstacles dans l’arène.
            <br>
            Le cohésion/séparation/alignement slider : permettent de
            modifier les différents coefficients de Boids.
            Le checkbutton Algo Ant: active l’algorithme de recherche de la
            colonie de fourmis.
            <br>
            Le checkbutton Algo Path Finding: active l’algorithme de
            recheche Path Finding.
            <br>
            Le checkbutton Path Finding: permet de diriger tous les boids
            vers le curseur de la souris.</p>
            <p>Pour mener a bien cette partie, nous utilisons une variables globales
            qui représente le status de l’algorithme de recherche choisit. 0 pour
            aucun, 1 pour l’algorithme des fourmis, 2 pour le l’algorithme de
            recherche path finding et 3 pour seulement le path finding d’un point
            A (position des boids) a B (position pointé par le curseur de la souris).</p>
            <p>Lorsqu’un boid trouve la cible il devient orange et le commu-
            nique a ses voisins les plus proches.
            Lorsqu’un boid passe a coté d’une phéromone il devient bleu clair et
            se dirige vers la cible</p>
            <p></p>
            <p></p>

        </div>
    </body></html>
